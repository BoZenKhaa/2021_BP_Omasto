

\chapter{Optimizing and Profiling}

TOHLE PLATI O VSECH ALGORITHMECH? BUDE SAI LEPSI TO PREPSAT DO OPTIMALIZACI

To some extent, the algorithm was written with list comprehensions or vectorizations, where it made sense. The utilization of vectorization was limited due to Julia's speed, often making the vectorizations slower than using for loops.


OPTIMIZATIONS

The optimizations were done using Profiler.jl which records the bottlenecks in the algorithm.

It turns out that even if the algorithm itself is optimized, the biggest bottleneck are user-defined functions, if not optimized correctly. Furthermore, the user-defined POMDPs definition bottlenecks usually have the same bottleneck, that is - they return values in list. Such functions are allocation small memory blocks each time they are called, up to million times, resulting in massive overhead in memory consumption. Such allocation can be however easily fixed by replacing them with generator expressions. In Julia, this is achieved by replacing square brackets with round brackets.


Optimizing allocations from pushing to preallocations.
Optimizing allocations by precomputing array only once instead of each time in for loop.